[{"path":"index.html","id":"引言","chapter":"1 引言","heading":"1 引言","text":"本教程简单介绍网络分析（network analysis）的一些基本方法及其在R语言中的应用。教程将首先从网络（network）或图（graph，和网络在这个教程中是一个意思）开始，简单介绍一些网络和图的相关概念，然后将介绍igraph、qgraph、NetworkToolbox等网络分析常用R包和相关操作。网络分析是心理学和社会科学研究中的一种常见的方法。在网络分析中，各种变量（心理特质、症状、因素、社会个体等等）被视为网络中的结点（node或者vertex），这些结点之间的直接联系使用边（edge）来表示。通过分析由这些结点和边构成的网络，我们能够得到一些新的发现。例如，在临床心理学领域，心理障碍是往往由由症状之间的相互作用导致的，而网络分析可以帮助我们理解这个由症状形成的网络。由于本人的研究领域关注临床心理学，因此本教程中的相关介绍也主要是在这一领域的研究中经常使用的方法，而一些其他研究领域中常用的网络分析方法可能并不在介绍范围内。关于心理学中的网络分析（特别是临床心理学领域）方法与进展，可以阅读以下的一些研究：蔡玉清, 董书阳, 袁帅 & 胡传鹏. (2020). 变量间的网络分析模型及其应用. 心理科学进展, (01), 178-195. https://doi.org/10.3724/SP.J.1042.2020.00178蔡玉清, 董书阳, 袁帅 & 胡传鹏. (2020). 变量间的网络分析模型及其应用. 心理科学进展, (01), 178-195. https://doi.org/10.3724/SP.J.1042.2020.00178Borsboom, D., Deserno, M. K., Rhemtulla, M., Epskamp, S., Fried, E. ., McNally, R. J., Robinaugh, D. J., Perugini, M., Dalege, J., Costantini, G., Isvoranu, .-M., Wysocki, . C., van Borkulo, C. D., van Bork, R., & Waldorp, L. J. (2021). Network analysis multivariate data psychological science. Nature Reviews Methods Primers, 1(1), 1–18. https://doi.org/10.1038/s43586-021-00055-wBorsboom, D., Deserno, M. K., Rhemtulla, M., Epskamp, S., Fried, E. ., McNally, R. J., Robinaugh, D. J., Perugini, M., Dalege, J., Costantini, G., Isvoranu, .-M., Wysocki, . C., van Borkulo, C. D., van Bork, R., & Waldorp, L. J. (2021). Network analysis multivariate data psychological science. Nature Reviews Methods Primers, 1(1), 1–18. https://doi.org/10.1038/s43586-021-00055-wBorsboom, D., & Cramer, . O. J. (2013). Network Analysis: Integrative Approach Structure Psychopathology. Annual Review Clinical Psychology, 9(1), 91–121. https://doi.org/10.1146/annurev-clinpsy-050212-185608Borsboom, D., & Cramer, . O. J. (2013). Network Analysis: Integrative Approach Structure Psychopathology. Annual Review Clinical Psychology, 9(1), 91–121. https://doi.org/10.1146/annurev-clinpsy-050212-185608Fried, E. ., van Borkulo, C. D., Cramer, . O. J., Boschloo, L., Schoevers, R. ., & Borsboom, D. (2017). Mental disorders networks problems: review recent insights. Social Psychiatry Psychiatric Epidemiology, 52(1), 1–10. https://doi.org/10.1007/s00127-016-1319-zFried, E. ., van Borkulo, C. D., Cramer, . O. J., Boschloo, L., Schoevers, R. ., & Borsboom, D. (2017). Mental disorders networks problems: review recent insights. Social Psychiatry Psychiatric Epidemiology, 52(1), 1–10. https://doi.org/10.1007/s00127-016-1319-z","code":""},{"path":"网络和图的基本概念.html","id":"网络和图的基本概念","chapter":"2 网络和图的基本概念","heading":"2 网络和图的基本概念","text":"","code":""},{"path":"网络和图的基本概念.html","id":"网络与图的概念","chapter":"2 网络和图的基本概念","heading":"2.1 网络与图的概念","text":"","code":""},{"path":"网络和图的基本概念.html","id":"结点与边","chapter":"2 网络和图的基本概念","heading":"2.1.1 结点与边","text":"网络（或图）1一般由结点和边组成。在心理学的网络分析中，结点（node或vertex）代表网络中的个体或实体，如心理特质、症状、因素、社会个体等等。边（edge）则表示结点之间的关系或连接，如相关性、因果关系、相互作用、社会关系等。","code":""},{"path":"网络和图的基本概念.html","id":"有向图与无向图","chapter":"2 网络和图的基本概念","heading":"2.1.2 有向图与无向图","text":"有向图（directed graph）中的边具有方向性，表示从一个结点指向另一个结点的关系。例如，微博上的关注关系就是有向的。在心理学的研究中，有时使用有向图来表示变量之间的因果关系。无向图（undirected graph）中的边没有方向性，表示结点之间的双向关系，如微信上的好友关系。很多临床心理学领域的网络分析就使用的是无向图，例如一个由多个变量之间的相关系数构成的网络就是无向图。下图就是一个关注多个临床心理学症状的网络分析的示例2。","code":""},{"path":"网络和图的基本概念.html","id":"有权图与无权图","chapter":"2 网络和图的基本概念","heading":"2.1.3 有权图与无权图","text":"有权图（weighted graph）中的边具有权重，表示关系的强度或容量。例如，一个描述各种心理症状关系的网络中的权重可能是症状之间的偏相关系数。无权图（unweighted graph）中的边没有权重，表示关系的存在或不存在。","code":""},{"path":"网络和图的基本概念.html","id":"图的表示邻接矩阵","chapter":"2 网络和图的基本概念","heading":"2.1.4 图的表示：邻接矩阵","text":"邻接矩阵（adjacency matrix）是一种表示图的方法，其中矩阵的行和列对应于图的结点，矩阵中的元素表示结点之间的边。例如，元素 \\(A_{ij}\\) 表示结点 \\(\\) 和结点 \\(j\\) 之间是否存在边。在有权图中，\\(A_{ij}\\) 也表示两个结点之间的权重。例如，一个包括5个结点的网络的邻接矩阵如下：\\[\n\\begin{bmatrix}\n0& 2.5& 0& 0& 7.8\\\\\n0& 0& 3.1& 0& 0\\\\\n0& 0& 0& 4.6& 0\\\\\n0& 0& 0& 0& 5.2\\\\\n0& 0& 0& 0& 0\n\\end{bmatrix}\n\\]可以绘制为这样的一个有向图：当然我们也会发现，对于刚才的邻接矩阵，矩阵中的大部分元素都是0。这样的稀疏矩阵在存储时效率较低，当结点数量很庞大时会占用大量空间（空间复杂度\\(O(n^2)\\)）。因此，除了使用邻接矩阵，我们也可以使用邻接表等方法表示一个图。","code":""},{"path":"网络和图的基本概念.html","id":"网络的基本性质","chapter":"2 网络和图的基本概念","heading":"2.2 网络的基本性质","text":"","code":""},{"path":"网络和图的基本概念.html","id":"路径","chapter":"2 网络和图的基本概念","heading":"2.2.1 路径","text":"对于一个图，我们往往会关心一个结点和另一个结点之间的关系，而要研究两个结点之间的关系，就不得不先知道两个结点之间的路径。路径（path）是指在图中从一个结点到另一个结点的结点序列。路径的长度由路径上的边数决定。如果路径序列中结点不重复出现，那我们称这个路径为简单路径。路径可以帮助分析网络中结点之间的可达性和距离。在计算结点间的路径时，我们有时还会遇到环。环（loop），又称回路，指的是第一个结点和最后一个结点相同的路径。有时从一个结点到另一个结点的路径可能有很多，但是这些路径之中一定有一个最短路径，即路径上边的权重之和最小的路径。而这个最短路径就是两个结点之间的距离。Dijkstra算法Dijkstra算法是荷兰计算机科学家Edsger W. Dijkstra于1956年提出的一种用于计算有权图中最短路径的经典算法。该算法适用于包含非负权重的有向图和无向图。Dijkstra算法的核心思想是通过贪心策略逐步扩展最近的未处理结点，并更新其邻居结点的距离，直到所有结点的最短路径都确定。具体步骤如下：初始化：从起始结点开始，设置起始结点到自身的距离为0，其他结点的距离为无穷大。将所有结点标记为未访问。初始化：从起始结点开始，设置起始结点到自身的距离为0，其他结点的距离为无穷大。将所有结点标记为未访问。选择结点：从未访问的结点中选择一个距离起始结点最近的结点作为当前结点。选择结点：从未访问的结点中选择一个距离起始结点最近的结点作为当前结点。更新距离：对于当前结点的每个邻居结点，计算从起始结点经过当前结点到达该邻居结点的距离。如果该距离小于当前记录的距离，则更新该邻居结点的距离。更新距离：对于当前结点的每个邻居结点，计算从起始结点经过当前结点到达该邻居结点的距离。如果该距离小于当前记录的距离，则更新该邻居结点的距离。标记访问：将当前结点标记为已访问。标记访问：将当前结点标记为已访问。重复：重复步骤2到4，直到所有结点都被访问。重复：重复步骤2到4，直到所有结点都被访问。","code":""},{"path":"网络和图的基本概念.html","id":"连通性","chapter":"2 网络和图的基本概念","heading":"2.2.2 连通性","text":"连通性（connectivity）描述了图中结点之间的连接程度。如果图中任意两个结点之间都存在路径我们就称这个图是连通的。连通性可以帮助识别网络中的孤立结点和子图。一个无向图中的极大连通子图称为连通分量（一个图可有多个）。在有向图中，如果对于每一对结点\\(\\)和\\(j\\)，从\\(\\)到\\(j\\)和从\\(j\\)到\\(\\)都存在路径，则称这个图是强连通图。有向图中的极大强连通子图称为强连通分量。图的遍历图的遍历指的是从图中某一结点出发访遍图中其余结点，且使每一个结点被访问且仅被访问一次。图的遍历算法是求解图的连通性问题、拓扑问题等算法的基础。图的遍历通常有两种方法：深度优先搜索（Depth-First Search, DFS）和广度优先搜索（Breadth-First Search, BFS）。深度优先搜索：从图的指定结点\\(v\\)出发，先访问结点\\(v\\)，并将其标记为已访问过，然后依次从\\(v\\)的未被访问过的邻接结点\\(w\\)出发进行深度优先搜索，直到图中与\\(v\\)相连的所有结点都被访问过。如果图中还有未被访问的结点，则从另一未被访问过的结点出发重复上述过程，直到图中所有结点都被访问过为止。广度优先搜索：从图的指定结点\\(v\\)出发，先访问结点\\(v\\)，接着依次访问\\(v\\)的所有邻结点\\(w_1\\), \\(w_2\\), … , \\(w_x\\)，然后，再依次访问与\\(w_1\\), \\(w_2\\), …, \\(w_x\\) 邻接的所有未被访问过的结点，以此类推，直到所有已访问结点的邻接结点都被访问过为止。如果图中还有未被访问过的结点，则从另一未被访问过的结点出发进行广度优先搜索，直到所有结点都被访问过为止。","code":""},{"path":"网络和图的基本概念.html","id":"结点的基本性质","chapter":"2 网络和图的基本概念","heading":"2.3 结点的基本性质","text":"","code":""},{"path":"网络和图的基本概念.html","id":"度","chapter":"2 网络和图的基本概念","heading":"2.3.1 度","text":"度（degree）是指一个结点连接的边的数量。在有向图中，度可以分为入度（-degree）和出度（-degree），分别表示指向该结点的边数和从该结点出发的边数。","code":""},{"path":"网络和图的基本概念.html","id":"中心性","chapter":"2 网络和图的基本概念","heading":"2.3.2 中心性","text":"中心性（centrality）是衡量结点在网络中重要性的一类指标。常见的中心性指标包括度中心性（degree centrality）、接近中心性（closeness centrality）、中介中心性（betweenness centrality）和特征向量中心性（eigenvector centrality）。这些指标可以帮助识别网络中的关键结点。","code":""},{"path":"网络和图的基本概念.html","id":"度中心性","chapter":"2 网络和图的基本概念","heading":"2.3.2.1 度中心性","text":"度中心性是衡量一个结点在网络中直接连接到其他结点数量的指标。它是最简单、最直观的中心性度量方法。无向图中的度中心性等于该结点的度，即与该节点直接相连的边的数量。有向图中的度中心性可以进一步分为入度中心性和出度中心性。入度中心性表示指向该结点的边的数量，出度中心性表示从该结点出发的边的数量。","code":""},{"path":"网络和图的基本概念.html","id":"接近中心性","chapter":"2 网络和图的基本概念","heading":"2.3.2.2 接近中心性","text":"接近中心性衡量一个结点到网络中所有其他结点的平均最短路径长度的倒数。接近中心性高的结点通常位于网络的中心位置，能够更快地与其他结点进行通信。结点\\(v\\)接近中心性的计算公式如下：\\[\n\\text{Closness Centrality} = \\frac{1}{\\sum_{\\neq v}d_{vi}}\n\\]其中，\\(\\)表示图中非\\(v\\)的结点，\\(d_{vi}\\)表示结点\\(v\\)到结点\\(\\)的最短路径。","code":""},{"path":"网络和图的基本概念.html","id":"中介中心性","chapter":"2 网络和图的基本概念","heading":"2.3.2.3 中介中心性","text":"中介中心性衡量一个结点在网络中作为其他结点对之间最短路径的中介程度。中介中心性高的结点在网络中起到“桥梁”作用，控制着信息的流动。结点\\(v\\)中介中心性的计算公式如下：\\[\n\\text{Betweenness Centrality} = \\sum_{\\neq j, \\neq v, j \\neq  v} \\frac{g_{ivj}}{g_{ij}}\n\\]其中，\\(g_{ij}\\)表示结点\\(\\)到结点\\(j\\)的最短路径的数量，\\(g_{ivj}\\)表示从\\(\\)到\\(j\\)的经过\\(v\\)的最短路径的数量。","code":""},{"path":"网络和图的基本概念.html","id":"特征向量中心性","chapter":"2 网络和图的基本概念","heading":"2.3.2.4 特征向量中心性","text":"特征向量中心性是一种衡量网络中结点重要性的方法。它不仅考虑结点的直接连接数量，还考虑这些连接结点本身的重要性。换句话说，一个结点的中心性不仅取决于它有多少邻居结点，还取决于这些邻居结点的中心性。特征向量中心性可以通过计算邻接矩阵的主特征向量来获得。","code":""},{"path":"igraph包的使用.html","id":"igraph包的使用","chapter":"3 igraph包的使用","heading":"3 igraph包的使用","text":"","code":""},{"path":"igraph包的使用.html","id":"igraph包简介","chapter":"3 igraph包的使用","heading":"3.1 igraph包简介","text":"igraph包是R语言中用于网络分析和图操作的强大工具。它提供了丰富的函数库，支持创建、操作、可视化和分析图结构。这一部分的教程将简单介绍igraph中一些重要的函数和操作。关于igraph的更多详细内容可以阅读该包的帮助文档或者访问igraph主页r.igraph.org。在开始之前请先安装并导入igraph。","code":"\n#install.packages(\"igraph\")\nlibrary('igraph')\n#> \n#> Attaching package: 'igraph'\n#> The following objects are masked from 'package:stats':\n#> \n#>     decompose, spectrum\n#> The following object is masked from 'package:base':\n#> \n#>     union"},{"path":"igraph包的使用.html","id":"创建igraph对象","chapter":"3 igraph包的使用","heading":"3.2 创建igraph对象","text":"igraph提供了很多创建图（igraph对象）的方法，下面列举几种常见的创建图的方法。","code":""},{"path":"igraph包的使用.html","id":"从边列表创建","chapter":"3 igraph包的使用","heading":"3.2.1 从边列表创建","text":"创建igraph对象最常用的方法是make_graph()，它会根据指定的边构建一个网络。 例如，要创建一个有8个结点（编号为1至8）以及连接结点1-2、2-3、3-4三条边的有向图：查看这个网络","code":"\nedges <- c(1, 2, 2, 3, 3, 4)\ng <- make_graph(edges, n = 8, directed = TRUE)\ng\n#> IGRAPH e07cecd D--- 8 3 -- \n#> + edges from e07cecd:\n#> [1] 1->2 2->3 3->4"},{"path":"igraph包的使用.html","id":"从邻接矩阵创建","chapter":"3 igraph包的使用","heading":"3.2.2 从邻接矩阵创建","text":"另外一种比较常用的创建igraph对象的方法是从邻接矩阵创建。在心理学研究中，邻接矩阵往往相对容易获得，例如我们可以使用各种估计方法（如qgraph中的EBICglasso）获得变量之间的相关系数矩阵，这个相关系数矩阵就可以作为邻接矩阵创建我们的图。这个邻接矩阵可以表示无权图：也可以表示有权图：","code":"\nadjacent_matrix <- matrix(sample(0:1, 100, replace = TRUE, prob = c(0.9, 0.1)), ncol = 10)\ng <- graph_from_adjacency_matrix(adjacent_matrix)\ng\n#> IGRAPH e084191 D--- 10 5 -- \n#> + edges from e084191:\n#> [1] 1->5 1->8 3->2 5->6 6->7\nadjacent_matrix <- matrix(sample(0:5, 100, replace = TRUE, prob = c(0.9, 0.02, 0.02, 0.02, 0.02, 0.02)), ncol = 10)\ng <- graph_from_adjacency_matrix(adjacent_matrix, weighted = TRUE)\ng\n#> IGRAPH e087c5b D-W- 10 8 -- \n#> + attr: weight (e/n)\n#> + edges from e087c5b:\n#> [1] 1->4 1->8 4->6 6->5 6->8 7->6 7->8 9->3"},{"path":"igraph包的使用.html","id":"生成随机网络","chapter":"3 igraph包的使用","heading":"3.2.3 生成随机网络","text":"igraph为我们提供了一系列生成随机图的方法，这些函数一般是sample_()。例如，我们可以使用sample_smallworld()生成一个Watts-Strogatz小世界网络。Watts-Strogatz小世界网络是一种特殊的复杂网络模型，由Duncan J. Watts和Steven Strogatz在1998年提出。这种网络模型结合了规则网络和随机网络的特性，具有高集聚系数（节点的邻居之间也有较高的连接概率，形成“团簇”）和短平均路径长度（尽管大部分节点彼此不直接相连，但通过少数几步就可以到达），能够很好地解释许多现实世界中的网络现象，如社交网络的“六度分隔”现象等。","code":"\ng <- sample_smallworld(1, 50, 5, 0.05)\nplot(g)"},{"path":"igraph包的使用.html","id":"网络可视化","chapter":"3 igraph包的使用","heading":"3.3 网络可视化","text":"对于一个igraph对象，我们可以直接使用plot()绘制。例如，我们可以创建一个20世纪70年代美国一所大学空手道俱乐部34名成员之间的社交网络3。当然，这只是最最简单的可视化方法，为了得到更加美观和有意义的可视化图形，我们可以采用很多方法。","code":"\nzachary_graph <- make_graph('Zachary')\nplot(zachary_graph)"},{"path":"igraph包的使用.html","id":"布局算法","chapter":"3 igraph包的使用","heading":"3.3.1 布局算法","text":"图是一个抽象的数学对象，在二维、三维或任何其他几何空间中都没有特定的表示形式。 这就意味着，无论何时我们想将图形可视化，都必须先找到二维或三维空间中顶点到坐标的映射。图论的一个独立分支，即图绘制，试图通过多种图布局算法来解决这个问题。igraph实现了很多布局算法，还能将它们绘制到屏幕上或R本身支持的任何输出格式。一种常见的布局是把所有结点放在在一个圆环上，可以使用layout_in_circle获得布局，这里得到的是一个N行2列的矩阵，代表了每个结点在二维空间中的坐标。当然，除了直接得到一个单独的布局的矩阵，我们也可以直接在plot中设置layout参数时指定布局算法。例如，我们可以采用Kamada-Kawai算法设计布局。Kamada-Kawai算法是一种用于图布局的力引导算法，旨在将图中的节点在二维或三维空间中进行美观的布局。该算法通过模拟物理系统中的弹簧力并使系统总能量最小化来实现节点的优化排列。如果不指定布局的话，默认采用Fruchterman-Reingold算法，这也是一种常用的力引导布局算法，该算法也基于物理模拟的思想，将结点视为带电粒子，通过斥力和引力的相互作用来调整节点的位置。除了这些igraph还提供了多种布局算法，详情可以访问igraph主页的相关介绍 https://r.igraph.org/articles/igraph.html#layout-algorithms。","code":"\ncircle_layout <- layout_in_circle(zachary_graph)\nplot(zachary_graph, layout = circle_layout, main = \"Zachary Social network with circle layout\")\nplot(zachary_graph, layout = layout_with_kk, main = \"Zachary Social network with the Kamada-Kawai layout algorithm\")"},{"path":"igraph包的使用.html","id":"自定义绘图","chapter":"3 igraph包的使用","heading":"3.3.2 自定义绘图","text":"除了布局算法，和R中的其他绘图工具一样，在使用plot绘制igraph对象时，我们可以通过多种参数进行自定义绘图，我们可以改变结点和边的大小、颜色等等。对于这些方法，igraph主页 https://r.igraph.org/articles/igraph.html#layouts--plotting 有详细介绍，这里不再赘述。","code":""},{"path":"igraph包的使用.html","id":"图的基本操作","chapter":"3 igraph包的使用","heading":"3.4 图的基本操作","text":"","code":""},{"path":"igraph包的使用.html","id":"边和结点的添加与删除","chapter":"3 igraph包的使用","heading":"3.4.1 边和结点的添加与删除","text":"在igraph中，我们还可以对图进行操作，例如添加结点或边：我们也可以删除边和结点。例如，我们想删除1和34之间的边可以这样操作：","code":"\nzachary_graph <- add_vertices(zachary_graph, 3)\nzachary_graph <- add_edges(zachary_graph, edges = c(1, 35, 1, 36, 34, 37))\nplot(zachary_graph)\nedge_id_to_delete <- get.edge.ids(zachary_graph, c(1, 35))\nedge_id_to_delete\n#> [1] 79\n\nzachary_graph <- delete_edges(zachary_graph, edge_id_to_delete)"},{"path":"igraph包的使用.html","id":"获得和修改结点和边的属性","chapter":"3 igraph包的使用","heading":"3.4.2 获得和修改结点和边的属性","text":"在igraph中，我们可以获得和修改图的边和结点属性。现在我们采用igraph主页的示例生成一个简单的社交网络。我们可以使用V()函数获得和修改结点属性。在这个网络中每个结点就是一个人，我们可以添加他们的年龄、性别等属性。同样，我们可以为网络中的边，也就是这些人之间的关系添加属性，比如这个关系是否正式。我们也可以用set_vertex_attr()和set_edge_attr()函数，道理是一样的。","code":"\nsocial_network <- make_graph(\n  ~ Alice - Boris:Himari:Moshe, Himari - Alice:Nang:Moshe:Samira,\n  Ibrahim - Nang:Moshe, Nang - Samira\n)\nplot(social_network)\nV(social_network)$age <- c(25, 31, 18, 23, 47, 22, 50)\nV(social_network)$gender <- c(\"f\", \"m\", \"f\", \"m\", \"m\", \"f\", \"m\")\nE(social_network)$is_formal <- c(FALSE, FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, FALSE, FALSE)\nsocial_network\n#> IGRAPH e0d0168 UN-- 7 9 -- \n#> + attr: name (v/c), age (v/n), gender (v/c),\n#> | is_formal (e/l)\n#> + edges from e0d0168 (vertex names):\n#> [1] Alice --Boris   Alice --Himari  Alice --Moshe  \n#> [4] Himari--Moshe   Himari--Nang    Himari--Samira \n#> [7] Moshe --Ibrahim Nang  --Samira  Nang  --Ibrahim"},{"path":"igraph包的使用.html","id":"图的基本分析","chapter":"3 igraph包的使用","heading":"3.5 图的基本分析","text":"","code":""},{"path":"igraph包的使用.html","id":"中心性指标","chapter":"3 igraph包的使用","heading":"3.5.1 中心性指标","text":"对于刚才的这个社交网络，我们可以计算每个结点的度。由于这个网络是一个无向图，因此不区分入度和出度。对于一个有向图，可以通过设置mode参数为\"\"和\"\"分别计算入度和出度。同样，我们可以计算每个结点的接近中心性（closeness centrality）、中介中心性（betweenness centrality）和特征向量中心性（eigenvector centrality）。除了这些中心性指标，igraph还有其他度量方法。","code":"\ndegree(social_network, mode = \"all\")\n#>   Alice   Boris  Himari   Moshe    Nang  Samira Ibrahim \n#>       3       1       4       3       3       2       2\nbetweenness(social_network)\n#>   Alice   Boris  Himari   Moshe    Nang  Samira Ibrahim \n#>     5.0     0.0     5.5     2.5     1.5     0.0     0.5\ncloseness(social_network)\n#>      Alice      Boris     Himari      Moshe       Nang \n#> 0.11111111 0.07142857 0.12500000 0.11111111 0.10000000 \n#>     Samira    Ibrahim \n#> 0.09090909 0.09090909\neigen_centrality(social_network)\n#> $vector\n#>     Alice     Boris    Himari     Moshe      Nang    Samira \n#> 0.7111995 0.2486011 1.0000000 0.7860027 0.7513989 0.6122047 \n#>   Ibrahim \n#> 0.5374016 \n#> \n#> $value\n#> [1] 2.860806\n#> \n#> $options\n#> $options$bmat\n#> [1] \"I\"\n#> \n#> $options$n\n#> [1] 7\n#> \n#> $options$which\n#> [1] \"LA\"\n#> \n#> $options$nev\n#> [1] 1\n#> \n#> $options$tol\n#> [1] 0\n#> \n#> $options$ncv\n#> [1] 0\n#> \n#> $options$ldv\n#> [1] 0\n#> \n#> $options$ishift\n#> [1] 1\n#> \n#> $options$maxiter\n#> [1] 3000\n#> \n#> $options$nb\n#> [1] 1\n#> \n#> $options$mode\n#> [1] 1\n#> \n#> $options$start\n#> [1] 1\n#> \n#> $options$sigma\n#> [1] 0\n#> \n#> $options$sigmai\n#> [1] 0\n#> \n#> $options$info\n#> [1] 0\n#> \n#> $options$iter\n#> [1] 23\n#> \n#> $options$nconv\n#> [1] 1\n#> \n#> $options$numop\n#> [1] 25\n#> \n#> $options$numopb\n#> [1] 0\n#> \n#> $options$numreo\n#> [1] 4"},{"path":"igraph包的使用.html","id":"路径与距离","chapter":"3 igraph包的使用","heading":"3.5.2 路径与距离","text":"我们可以使用shortest_paths()计算结点之间的最短路径。我们也可以用distances()计算结点之间的距离矩阵。","code":"\nshortest_paths(social_network, \"Alice\", \"Nang\")\n#> $vpath\n#> $vpath[[1]]\n#> + 3/7 vertices, named, from e0d0168:\n#> [1] Alice  Himari Nang  \n#> \n#> \n#> $epath\n#> NULL\n#> \n#> $predecessors\n#> NULL\n#> \n#> $inbound_edges\n#> NULL\ndistances(social_network)\n#>         Alice Boris Himari Moshe Nang Samira Ibrahim\n#> Alice       0     1      1     1    2      2       2\n#> Boris       1     0      2     2    3      3       3\n#> Himari      1     2      0     1    1      1       2\n#> Moshe       1     2      1     0    2      2       1\n#> Nang        2     3      1     2    0      1       1\n#> Samira      2     3      1     2    1      0       2\n#> Ibrahim     2     3      2     1    1      2       0"},{"path":"igraph包的使用.html","id":"连通性-1","chapter":"3 igraph包的使用","heading":"3.5.3 连通性","text":"在igraph中，我们也可以计算图的连通性和连通分量。我们可以首先生成一个随机的图。这个图显然是不连通的。我们可以用is_connected检查一个图是否连通。我们可以用components()计算连通分量。","code":"\nadjacent_matrix <- matrix(sample(0:1, 100, replace = TRUE, prob = c(0.9, 0.1)), ncol = 10)\ng <- graph_from_adjacency_matrix(adjacent_matrix)\nplot(g)\nis_connected(g)\n#> [1] FALSE\ncomponents(g)\n#> $membership\n#>  [1] 1 2 3 2 2 2 2 2 2 4\n#> \n#> $csize\n#> [1] 1 7 1 1\n#> \n#> $no\n#> [1] 4"},{"path":"igraph包的使用.html","id":"社区检测","chapter":"3 igraph包的使用","heading":"3.6 社区检测","text":"社区检测（Community Detection）是网络分析中的一种技术，用于识别网络中节点的聚集行为，即将网络划分为若干个社区或聚类，有时社区检测也称为聚类（clustering），但不同于一般意义上的聚类。社区内的结点彼此之间连接紧密，而社区之间的结点连接相对稀疏。社区检测在心理学的网络分析中应用十分广泛，例如，我们可以对症状网络进行社区检测，研究各种精神障碍之间的共病关系。","code":""},{"path":"igraph包的使用.html","id":"聚类系数","chapter":"3 igraph包的使用","heading":"3.6.1 聚类系数","text":"传递性（transitivity）又称聚类系数（clustering coefficient）， 测量的是一个结点的相邻顶点结点的概率。聚类系数包括两类：结点水平的局部聚类系数和网络水平的全局聚类系数。对于有权图的聚类系数有几种描述，这里我们使用A. Barrat的定义4，这是一个结点水平的局部聚类系数，其公式为\\[\nC_i^w = \\frac{1}{s_i(k_i-1)}\\sum_{j,h}\\frac{w_{ij}+w_{ih}}{2}a_{ij}a_{ih}a_{jh}\n\\]其中，\\(s_i\\)指结点\\(\\)的强度（该结点相连边权重之和），\\(a_{ij}\\)是邻接矩阵中的元素，\\(k_i\\)指结点\\(\\)的度，\\(w_{ij}\\)为边权重。在igraph中可以使用transitivity()计算。以一个随机生成的小世界网络为例。","code":"\ng <- sample_smallworld(1, 50, 5, 0.05)\ntransitivity(g)\n#> [1] 0.4940555"},{"path":"igraph包的使用.html","id":"边中介edge-betweenness算法","chapter":"3 igraph包的使用","heading":"3.6.2 边中介（Edge Betweenness）算法","text":"边中介（Edge Betweenness）算法通过计算每条边在网络中作为桥梁的程度来识别社区。该算法基于中介中心性（Edge Betweenness Centrality），即一条边在所有最短路径中出现的频率。算法通过迭代删除中介中心性最高的边，逐步将网络分割成多个子图。每次删除一条边后，重新计算剩余边的中介中心性，直到网络被分割成若干个社区。该算法适用于小规模网络，因为大规模网络所需计算资源较高。","code":"\ncluster_edge_betweenness(g)\n#> IGRAPH clustering edge betweenness, groups: 4, mod: 0.45\n#> + groups:\n#>   $`1`\n#>    [1]  1  2  3  4  5  6  7  8  9 10 49 50\n#>   \n#>   $`2`\n#>   [1] 11 12 13 14 15 16 17 18 19\n#>   \n#>   $`3`\n#>    [1] 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34\n#>   \n#>   $`4`\n#>   + ... omitted several groups/vertices\nplot(g, \n     layout = layout,\n     vertex.color = cluster_edge_betweenness(g)$membership)"},{"path":"igraph包的使用.html","id":"标签传播label-propagation算法","chapter":"3 igraph包的使用","heading":"3.6.3 标签传播（Label Propagation）算法","text":"标签传播（Label Propagation）算法是一种用于检测网络中社区结构的快速、近乎线性时间复杂度的算法。它的工作原理是给结点贴上唯一的标签，然后通过结点附近的多数投票来更新标签。适用于大规模网络，计算速度快。","code":"\ncluster_label_prop(g)\n#> IGRAPH clustering label propagation, groups: 3, mod: 0.44\n#> + groups:\n#>   $`1`\n#>    [1]  1  2  3 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49\n#>   [19] 50\n#>   \n#>   $`2`\n#>    [1]  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19\n#>   \n#>   $`3`\n#>    [1] 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34\n#> \nplot(g, \n     layout = layout,\n     vertex.color = cluster_label_prop(g)$membership)"},{"path":"igraph包的使用.html","id":"louvain算法","chapter":"3 igraph包的使用","heading":"3.6.4 Louvain算法","text":"Louvain算法是一种基于模块度（modularity）优化的社区检测算法，广泛应用于大规模网络的社区发现。该算法由Vincent Blondel等人于2008年提出，旨在通过多层次的优化过程，快速、准确地识别网络中的社区结构。Louvain算法的核心思想是通过最大化模块度来识别社区。模块度是衡量社区划分质量的指标，表示社区内结点之间的连接密度与随机情况下的连接密度之差。算法开始时，每个结点都会被单独分配到一个社区。在每一步中，结点都会以一种局部的、贪心的方式被重新分配到社区中：每个结点都会被移动到对模块化程度贡献最大的社区中。当没有结点可以重新分配时，每个社区就会被视为一个单独的结点，然后再从合并后的社区开始重新分配。当只剩下一个结点或模块度无法再增加时，该过程就会停止。自igraph 1.3版本起，结点将以随机顺序处理，因此算法结果可能不稳定。","code":"\ncluster_louvain(g)\n#> IGRAPH clustering multi level, groups: 4, mod: 0.45\n#> + groups:\n#>   $`1`\n#>    [1]  1  2  3  4  5  6  7  8  9 10 11 48 49 50\n#>   \n#>   $`2`\n#>   [1] 12 13 14 15 16 17 18 19\n#>   \n#>   $`3`\n#>    [1] 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37\n#>   \n#>   $`4`\n#>   + ... omitted several groups/vertices\nplot(g, \n     layout = layout,\n     vertex.color = cluster_louvain(g)$membership)"},{"path":"igraph包的使用.html","id":"随机游走walktrap算法","chapter":"3 igraph包的使用","heading":"3.6.5 随机游走（Walktrap）算法","text":"随机游走（Walktrap）算法是一种基于随机游走的社区检测算法，通过模拟随机游走来测量节点之间的相似性，其思想是短程随机游走往往会停留在同一个社区中。","code":"\ncluster_walktrap(g)\n#> IGRAPH clustering walktrap, groups: 3, mod: 0.45\n#> + groups:\n#>   $`1`\n#>    [1]  1  2  3  4  5  6 39 40 41 42 43 44 45 46 47 48 49 50\n#>   \n#>   $`2`\n#>    [1] 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37\n#>   [19] 38\n#>   \n#>   $`3`\n#>    [1]  7  8  9 10 11 12 13 14 15 16 17 18 19\n#> \nplot(g, \n     layout = layout,\n     vertex.color = cluster_walktrap(g)$membership)"},{"path":"igraph包的使用.html","id":"信息映射infomap算法","chapter":"3 igraph包的使用","heading":"3.6.6 信息映射（Infomap）算法","text":"信息映射（Infomap）算法是一种基于信息论的社区检测算法，通过最小化随机游走的预期描述长度来识别网络中的社区结构。","code":"\ncluster_infomap(g)\n#> IGRAPH clustering infomap, groups: 3, mod: 0.46\n#> + groups:\n#>   $`1`\n#>    [1]  1  2  3  4  5 38 39 40 41 42 43 44 45 46 47 48 49 50\n#>   \n#>   $`2`\n#>    [1]  6  7  8  9 10 11 12 13 14 15 16 17 18 19\n#>   \n#>   $`3`\n#>    [1] 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37\n#> \nplot(g, \n     layout = layout,\n     vertex.color = cluster_infomap(g)$membership)"},{"path":"igraph包的使用.html","id":"自旋玻璃spinglass算法","chapter":"3 igraph包的使用","heading":"3.6.7 自旋玻璃（Spinglass）算法","text":"自旋玻璃（Spinglass）算法是一种基于物理学中自旋玻璃模型的社区检测算法。该算法通过模拟自旋玻璃系统中的能量最小化过程，将网络中的结点划分为不同的社区，以最大化社区内部的连接强度。这种算法能够处理带有权重和方向的复杂网络（甚至是负权重）。除了以上介绍的几种算法，igraph还提供了其他算法，如特征向量（Leading Eigenvector）算法等，可以根据实际研究的需要选择。","code":"\ncluster_spinglass(g)\n#> IGRAPH clustering spinglass, groups: 4, mod: 0.46\n#> + groups:\n#>   $`1`\n#>    [1]  1  2  3  4  5 41 42 43 44 45 46 47 48 49 50\n#>   \n#>   $`2`\n#>   [1] 32 33 34 35 36 37 38 39 40\n#>   \n#>   $`3`\n#>    [1]  6  7  8  9 10 11 12 13 14 15 16 17 18 19\n#>   \n#>   $`4`\n#>   + ... omitted several groups/vertices\nplot(g, \n     layout = layout,\n     vertex.color = cluster_spinglass(g)$membership)"},{"path":"qgraph包的使用.html","id":"qgraph包的使用","chapter":"4 qgraph包的使用","heading":"4 qgraph包的使用","text":"","code":""},{"path":"networktoolbox的使用.html","id":"networktoolbox的使用","chapter":"5 NetworkToolbox的使用","heading":"5 NetworkToolbox的使用","text":"","code":""}]
